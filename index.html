<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Power Sandbox (Paste Code) — Enhanced Dummy FX</title>
  <style>
    :root { color-scheme: dark; }
    body { margin:0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial; background:#0b0f14; color:#e6edf3; }
    .wrap { display:grid; grid-template-columns: 1.3fr 0.7fr; gap:12px; padding:12px; height:100vh; box-sizing:border-box; }
    .card { background:#0f1620; border:1px solid #1f2a3a; border-radius:12px; overflow:hidden; box-shadow: 0 6px 18px rgba(0,0,0,.25); }
    .topbar { display:flex; gap:8px; align-items:center; padding:10px; border-bottom:1px solid #1f2a3a; }
    .btn { background:#1b2a3d; border:1px solid #2b3d57; color:#e6edf3; padding:8px 10px; border-radius:10px; cursor:pointer; }
    .btn:hover { filter:brightness(1.08); }
    .btn:active { transform: translateY(1px); }
    .btn.primary { background:#2356a6; border-color:#2f6bd0; }
    .btn.danger { background:#5a1e2a; border-color:#7b2a3b; }
    .kbd { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; font-size:12px; color:#b9c6d6; padding:2px 6px; border:1px solid #2b3d57; border-radius:8px; background:#0b111a; }
    canvas { width:100%; height:calc(100% - 44px); display:block; }
    .side { display:flex; flex-direction:column; height:100%; }
    .side .card { display:flex; flex-direction:column; min-height:0; }
    .side .body { padding:10px; display:flex; flex-direction:column; gap:10px; min-height:0; }
    textarea {
      width:100%; min-height: 260px; resize: vertical;
      background:#0b111a; color:#e6edf3; border:1px solid #2b3d57; border-radius:10px;
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; font-size:12px; line-height:1.35;
      padding:10px; box-sizing:border-box;
    }
    .row { display:flex; gap:8px; flex-wrap:wrap; }
    .small { font-size:12px; color:#b9c6d6; line-height:1.35; }
    .log {
      background:#0b111a; border:1px solid #2b3d57; border-radius:10px;
      padding:10px; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      font-size:12px; color:#cfe3ff; overflow:auto; min-height:120px; max-height:220px;
      white-space:pre-wrap;
    }
    .pill { padding:2px 8px; border:1px solid #2b3d57; border-radius:999px; background:#0b111a; font-size:12px; color:#b9c6d6; }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="card">
      <div class="topbar">
        <button class="btn primary" id="btnFire">Fire <span class="kbd">Space</span></button>
        <button class="btn" id="btnReset">Reset Arena</button>
        <span class="pill" id="statusPill">No power loaded</span>
        <span class="pill" id="hpPill">HP — Player: 100 | Dummy: 300</span>
        <span style="margin-left:auto" class="small">Aim: mouse • Move <span class="kbd">WASD</span></span>
      </div>
      <canvas id="cv"></canvas>
    </div>

    <div class="side">
      <div class="card" style="flex:1">
        <div class="topbar">
          <button class="btn" id="btnCopyInstructions">Copy Instructions</button>
          <button class="btn" id="btnLoadPower">Load Pasted Power</button>
          <button class="btn danger" id="btnLoadExample">Load Example</button>
        </div>
        <div class="body">
          <div class="small">
            Paste a <b>power module</b> that calls <span class="kbd">registerPower(...)</span>.
            Your code is executed locally in this page.
          </div>
          <textarea id="powerCode" spellcheck="false" placeholder="// Paste power code here..."></textarea>
          <div class="row">
            <button class="btn" id="btnClear">Clear</button>
            <button class="btn" id="btnCopyLastPower">Copy Last Loaded</button>
          </div>
          <div class="small">Console / errors:</div>
          <div class="log" id="log"></div>
        </div>
      </div>
    </div>
  </div>

<script>
/**
 * POWER SANDBOX (Enhanced Dummy FX)
 * - Arena: left = player, right = dummy.
 * - Paste code defines a projectile/blast power with custom:
 *   shape, trail, speed, damage, onHitCharacter, dummy effect
 *
 * SECURITY NOTE:
 * This uses Function() to run pasted JS. Only paste code you trust.
 */

(() => {
  // ---------- Utilities ----------
  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
  const lerp = (a, b, t) => a + (b - a) * t;
  const now = () => performance.now();

  function randSeeded(seed) {
    let s = seed >>> 0;
    return () => {
      s = (s * 1664525 + 1013904223) >>> 0;
      return (s & 0xfffffff) / 0x10000000;
    };
  }

  // ---------- DOM ----------
  const cv = document.getElementById("cv");
  const ctx = cv.getContext("2d");
  const logEl = document.getElementById("log");
  const statusPill = document.getElementById("statusPill");
  const hpPill = document.getElementById("hpPill");

  const powerCodeEl = document.getElementById("powerCode");
  const btnLoadPower = document.getElementById("btnLoadPower");
  const btnLoadExample = document.getElementById("btnLoadExample");
  const btnCopyInstructions = document.getElementById("btnCopyInstructions");
  const btnFire = document.getElementById("btnFire");
  const btnReset = document.getElementById("btnReset");
  const btnClear = document.getElementById("btnClear");
  const btnCopyLastPower = document.getElementById("btnCopyLastPower");

  function log(msg) {
    logEl.textContent += (logEl.textContent ? "\n" : "") + msg;
    logEl.scrollTop = logEl.scrollHeight;
  }
  function clearLog() { logEl.textContent = ""; }

  // ---------- Canvas sizing ----------
  function resize() {
    const rect = cv.getBoundingClientRect();
    const dpr = Math.max(1, Math.floor(window.devicePixelRatio || 1));
    cv.width = Math.floor(rect.width * dpr);
    cv.height = Math.floor(rect.height * dpr);
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  }
  window.addEventListener("resize", resize);
  resize();

  // ---------- World ----------
  const world = {
    w: () => cv.getBoundingClientRect().width,
    h: () => cv.getBoundingClientRect().height,
    time: 0,
    dt: 0,
    last: now(),

    player: { x: 140, y: 220, r: 16, hp: 100, maxHp: 100, isDead:false, respawnAt:0, hitFx: [], deathFx: [] },

    dummy: {
      x: 0, y: 0, w: 54, h: 90, hp: 300, maxHp: 300, isDead:false, respawnAt:0, deathFx: [],
      effects: {
        phys: { vx: 0, vy: 0, spin: 0, shake: 0 },
        deform: { squash: 0, stretch: 0, shearX: 0, wave: 0 },
        surface: { heat: 0, frost: 0, corrosion: 0, wet: 0, tint: 0 },
        fracture: { amount: 0, seed: 12345, lines: [] },
        aura: { intensity: 0, radius: 0, flicker: 0, hue: 190 },
        disintegrate: { amount: 0, shedRate: 0, eraseTo: 0 },
        slice: { active: false, parts: [] },
        status: { poisoned: 0, bleeding: 0 }
      }
    },

    projectiles: [],
    particles: [],
    currentPower: null,
    lastLoadedCode: "",
    mouse: { x: 0, y: 0, down: false },
    keys: new Set(),
  };

  // ---------- Dummy effect helpers ----------
  function dummyCenter(d) {
    return { cx: d.x + d.w * 0.5, cy: d.y + d.h * 0.5 };
  }

  function addKnockback(d, vx, vy, spin = 0) {
    d.effects.phys.vx += vx;
    d.effects.phys.vy += vy;
    d.effects.phys.spin += spin;
    d.effects.phys.shake = Math.min(1, d.effects.phys.shake + 0.6);
  }

  function genCracks(d, seed, count) {
    let s = seed >>> 0;
    const rnd = () => (s = (s * 1664525 + 1013904223) >>> 0, (s & 0xfffffff) / 0x10000000);

    const lines = [];
    const { cx, cy } = dummyCenter(d);

    for (let i = 0; i < count; i++) {
      const x0 = d.x + rnd() * d.w;
      const y0 = d.y + rnd() * d.h;
      const pts = [{ x: x0, y: y0 }];

      const segs = 3 + Math.floor(rnd() * 6);
      let x = x0, y = y0;
      for (let k = 0; k < segs; k++) {
        const a = rnd() * Math.PI * 2;
        const step = 6 + rnd() * 16;
        x += Math.cos(a) * step;
        y += Math.sin(a) * step;
        x = Math.max(d.x, Math.min(d.x + d.w, x));
        y = Math.max(d.y, Math.min(d.y + d.h, y));
        pts.push({ x, y });
      }

      if (rnd() < 0.35) pts.push({ x: cx, y: cy });
      lines.push(pts);
    }
    return lines;
  }

  function addFracture(d, amount, seed = ((Math.random() * 1e9) | 0)) {
    d.effects.fracture.amount = Math.min(1, d.effects.fracture.amount + amount);
    d.effects.fracture.seed = seed;
    d.effects.fracture.lines = genCracks(d, seed, 10 + Math.floor(18 * d.effects.fracture.amount));
  }

  function setAura(d, intensity, radius, hue = 190, flicker = 0.6) {
    d.effects.aura.intensity = Math.max(d.effects.aura.intensity, intensity);
    d.effects.aura.radius = Math.max(d.effects.aura.radius, radius);
    d.effects.aura.hue = hue;
    d.effects.aura.flicker = flicker;
  }

  function setSurface(d, { heat=0, frost=0, corrosion=0, wet=0, tint=0 } = {}) {
    d.effects.surface.heat = Math.max(d.effects.surface.heat, heat);
    d.effects.surface.frost = Math.max(d.effects.surface.frost, frost);
    d.effects.surface.corrosion = Math.max(d.effects.surface.corrosion, corrosion);
    d.effects.surface.wet = Math.max(d.effects.surface.wet, wet);
    d.effects.surface.tint = Math.max(d.effects.surface.tint, tint);
  }

  function startDisintegration(d, amount, shedRate = 60, eraseTo = 0.6) {
    d.effects.disintegrate.amount = Math.max(d.effects.disintegrate.amount, amount);
    d.effects.disintegrate.shedRate = Math.max(d.effects.disintegrate.shedRate, shedRate);
    d.effects.disintegrate.eraseTo = Math.max(d.effects.disintegrate.eraseTo, eraseTo);
  }

  function setStatus(d, { poisoned=0, bleeding=0 } = {}) {
    d.effects.status.poisoned = Math.max(d.effects.status.poisoned, poisoned);
    d.effects.status.bleeding = Math.max(d.effects.status.bleeding, bleeding);
  }

  function sliceDummy(d, partsCount = 2, directionAngle = 0.7) {
    d.effects.slice.active = true;
    d.effects.slice.parts = [];

    const cols = Math.max(1, Math.round(Math.sqrt(partsCount)));
    const rows = Math.max(1, Math.ceil(partsCount / cols));
    const pw = d.w / cols;
    const ph = d.h / rows;

    let idx = 0;
    for (let r = 0; r < rows; r++) {
      for (let c = 0; c < cols; c++) {
        if (idx >= partsCount) break;
        const x = d.x + c * pw;
        const y = d.y + r * ph;

        const bias = (idx / Math.max(1, partsCount - 1)) - 0.5;
        const sep = 90;
        const vx = Math.cos(directionAngle) * sep * bias;
        const vy = Math.sin(directionAngle) * sep * bias;

        d.effects.slice.parts.push({
          x, y, w: pw, h: ph,
          vx, vy,
          spin: (Math.random() * 2 - 1) * 2.2,
          age: 0,
          life: 1.2 + Math.random() * 0.7,
          alpha: 1
        });
        idx++;
      }
    }
  }

  // ---------- World reset ----------
  function resetArena() {
    world.projectiles.length = 0;
    world.particles.length = 0;
    world.player.hp = world.player.maxHp;
    world.player.isDead = false;
    world.player.respawnAt = 0;
    world.player.hitFx.length = 0;
    world.player.deathFx.length = 0;

    // place dummy on right half
    const W = world.w(), H = world.h();
    world.player.x = 140;
    world.player.y = H * 0.5;

    world.dummy.x = W - 180;
    world.dummy.y = H * 0.5 - world.dummy.h * 0.5;
    world.dummy.hp = world.dummy.maxHp;
    world.dummy.isDead = false;
    world.dummy.respawnAt = 0;
    world.dummy.deathFx.length = 0;

    // reset effects
    const e = world.dummy.effects;
    e.phys = { vx: 0, vy: 0, spin: 0, shake: 0 };
    e.deform = { squash: 0, stretch: 0, shearX: 0, wave: 0 };
    e.surface = { heat: 0, frost: 0, corrosion: 0, wet: 0, tint: 0 };
    e.fracture = { amount: 0, seed: 12345, lines: [] };
    e.aura = { intensity: 0, radius: 0, flicker: 0, hue: 190 };
    e.disintegrate = { amount: 0, shedRate: 0, eraseTo: 0 };
    e.slice = { active: false, parts: [] };
    e.status = { poisoned: 0, bleeding: 0 };

    log("Arena reset.");
  }

  resetArena();

  // ---------- Input ----------
  cv.addEventListener("mousemove", (e) => {
    const rect = cv.getBoundingClientRect();
    world.mouse.x = e.clientX - rect.left;
    world.mouse.y = e.clientY - rect.top;
  });
  cv.addEventListener("mousedown", () => world.mouse.down = true);
  window.addEventListener("mouseup", () => world.mouse.down = false);

  window.addEventListener("keydown", (e) => {
    world.keys.add(e.code);
    if (e.code === "Space") {
      e.preventDefault();
      fire();
    }
  });
  window.addEventListener("keyup", (e) => world.keys.delete(e.code));

  // ---------- Power API ----------
  function validatePower(p) {
    const required = ["meta", "createProjectile"];
    for (const k of required) if (!(k in p)) throw new Error(`Power missing required field: ${k}`);
    const m = p.meta || {};
    for (const k of ["name", "id", "description"]) if (!m[k]) throw new Error(`Power meta missing: meta.${k}`);
    if (typeof p.createProjectile !== "function") throw new Error(`createProjectile must be a function`);
  }

  function setCurrentPower(power, sourceCode) {
    validatePower(power);
    world.currentPower = power;
    world.lastLoadedCode = sourceCode || "";
    statusPill.textContent = `Loaded: ${power.meta.name} (${power.meta.id})`;
    log(`Loaded power: ${power.meta.name} (${power.meta.id})`);
  }

  // exposed to pasted scripts
  function registerPower(powerDef) {
    setCurrentPower(powerDef, "__PASTED__");
  }

  function powerContext() {
    return {
      player: { x: world.player.x, y: world.player.y },
      mouse:  { x: world.mouse.x, y: world.mouse.y },

      arena: {
        width: world.w(),
        height: world.h(),
        midX: world.w() * 0.5
      },

      clamp, lerp,

      spawnParticle: (pt) => world.particles.push(pt),

      applyDamageToPlayer: (amount, sourceProjectile) => applyDamageToCharacter(world.player, amount, sourceProjectile),
      applyDamageToDummy: (amount, sourceProjectile) => {
        const d = world.dummy;
        if (d.isDead) return;
        const prevHp = d.hp;
        d.hp -= amount;
        if (d.hp <= 0 && !d.isDead) {
          d.isDead = true;
          d.hp = 0;
          d.respawnAt = world.time + 1.25;
          if (sourceProjectile && sourceProjectile.onKillDummy) {
            try {
              sourceProjectile.onKillDummy({ world, projectile: sourceProjectile, dummy: d, damage: amount, prevHp, overkill: Math.max(0, -(prevHp - amount)), time: world.time });
            } catch (e) {
              log("onKillDummy ERROR: " + (e?.message || e));
            }
          }
        }
      },

      rng: randSeeded((Math.random() * 1e9) | 0),

      dummyHelpers: {
        addKnockback: (vx, vy, spin) => addKnockback(world.dummy, vx, vy, spin),
        addFracture: (amount, seed) => addFracture(world.dummy, amount, seed),
        setAura: (intensity, radius, hue, flicker) => setAura(world.dummy, intensity, radius, hue, flicker),
        setSurface: (opts) => setSurface(world.dummy, opts),
        startDisintegration: (amount, shedRate, eraseTo) => startDisintegration(world.dummy, amount, shedRate, eraseTo),
        setStatus: (opts) => setStatus(world.dummy, opts),
        sliceDummy: (partsCount, directionAngle) => sliceDummy(world.dummy, partsCount, directionAngle)
      }
    };
  }

  // ---------- Projectile creation ----------
  function spawnProjectileFromPower() {
    const P = world.currentPower;
    if (!P) return;

    const ctxIn = powerContext();
    const spec = P.createProjectile(ctxIn);

    const must = ["speed", "damage", "shape", "trail", "onHitCharacter", "onHitDummy"]; // onKillCharacter/onKillDummy optional
    for (const k of must) if (!(k in spec)) throw new Error(`Projectile spec missing: ${k}`);

    if (typeof spec.shape.draw !== "function") throw new Error("shape.draw(ctx, proj, t) must be a function");
    if (typeof spec.trail.emit !== "function") throw new Error("trail.emit(world, proj, t) must be a function");
    if (typeof spec.onHitCharacter !== "function") throw new Error("onHitCharacter must be a function");
    if (typeof spec.onHitDummy !== "function") throw new Error("onHitDummy must be a function");

    const dx = (world.mouse.x - world.player.x);
    const dy = (world.mouse.y - world.player.y);
    const len = Math.max(1e-6, Math.hypot(dx, dy));
    const vx = (dx / len) * spec.speed;
    const vy = (dy / len) * spec.speed;

    world.projectiles.push({
      x: world.player.x,
      y: world.player.y,
      vx, vy,
      speed: spec.speed,
      damage: spec.damage,
      life: spec.life ?? 2.8,
      age: 0,
      radius: spec.radius ?? 10,
      shape: spec.shape,
      trail: spec.trail,
      onHitCharacter: spec.onHitCharacter,
      onHitDummy: spec.onHitDummy,
      onKillCharacter: (typeof spec.onKillCharacter==="function") ? spec.onKillCharacter : null,
      onKillDummy: (typeof spec.onKillDummy==="function") ? spec.onKillDummy : null,
      state: spec.state ?? {},
      meta: spec.meta ?? {}
    });
  }

  // ---------- Fire ----------
  function fire() {
    try {
      if (!world.currentPower) return log("No power loaded.");
      if (world.player.isDead) return log("Player is dead (respawning).");
      spawnProjectileFromPower();
    } catch (err) {
      log("FIRE ERROR: " + (err?.message || err));
    }
  }
  btnFire.addEventListener("click", fire);

  // ---------- Movement ----------
  function stepMovement(dt) {
    const sp = 220;
    let mx = 0, my = 0;
    if (world.keys.has("KeyW")) my -= 1;
    if (world.keys.has("KeyS")) my += 1;
    if (world.keys.has("KeyA")) mx -= 1;
    if (world.keys.has("KeyD")) mx += 1;
    const ml = Math.hypot(mx, my);
    if (ml > 0) { mx /= ml; my /= ml; }

    world.player.x += mx * sp * dt;
    world.player.y += my * sp * dt;

    const W = world.w(), H = world.h();
    world.player.x = clamp(world.player.x, 30, W * 0.5 - 30);
    world.player.y = clamp(world.player.y, 30, H - 30);
  }

  // ---------- Collisions ----------
  function circleRectCollides(cx, cy, r, rx, ry, rw, rh) {
    const px = clamp(cx, rx, rx + rw);
    const py = clamp(cy, ry, ry + rh);
    const dx = cx - px, dy = cy - py;
    return (dx*dx + dy*dy) <= r*r;
  }

  
  function applyDamageToCharacter(character, amount, sourceProj) {
    if (character.isDead) return;
    const prevHp = character.hp;
    character.hp -= amount;
    if (character.hp <= 0) {
      character.isDead = true;
      character.hp = 0;
      character.respawnAt = world.time + 1.25;

      if (sourceProj && sourceProj.onKillCharacter) {
        try {
          sourceProj.onKillCharacter({
            world,
            projectile: sourceProj,
            character,
            damage: amount,
            prevHp,
            overkill: Math.max(0, -(prevHp - amount)),
            time: world.time
          });
        } catch (e) {
          log("onKillCharacter ERROR: " + (e?.message || e));
        }
      } else {
        // default death sparkle
        for (let k = 0; k < 36; k++) {
          const a = (k / 36) * Math.PI * 2;
          const sp = 120 + Math.random() * 220;
          world.particles.push({
            x: character.x, y: character.y,
            vx: Math.cos(a) * sp, vy: Math.sin(a) * sp - 40,
            life: 0.7, age: 0,
            draw(g, pt) {
              const t = 1 - pt.age / pt.life;
              g.globalAlpha = Math.max(0, t) * 0.35;
              g.fillStyle = "rgba(160,210,255,0.14)";
              g.fillRect(pt.x - 1, pt.y - 1, 2, 2);
              g.globalAlpha = 1;
            }
          });
        }
      }
    }
  }
function hitDummy(proj) {
    try {
      proj.onHitDummy({
        world,
        projectile: proj,
        dummy: world.dummy,
        damage: proj.damage,
        spawnParticle: (pt) => world.particles.push(pt),

      applyDamageToPlayer: (amount, sourceProjectile) => applyDamageToCharacter(world.player, amount, sourceProjectile),
      applyDamageToDummy: (amount, sourceProjectile) => {
        const d = world.dummy;
        if (d.isDead) return;
        const prevHp = d.hp;
        d.hp -= amount;
        if (d.hp <= 0 && !d.isDead) {
          d.isDead = true;
          d.hp = 0;
          d.respawnAt = world.time + 1.25;
          if (sourceProjectile && sourceProjectile.onKillDummy) {
            try {
              sourceProjectile.onKillDummy({ world, projectile: sourceProjectile, dummy: d, damage: amount, prevHp, overkill: Math.max(0, -(prevHp - amount)), time: world.time });
            } catch (e) {
              log("onKillDummy ERROR: " + (e?.message || e));
            }
          }
        }
      },
        time: world.time
      });
    } catch (e) {
      log("onHitDummy ERROR: " + (e?.message || e));
    }
  }

  function hitCharacter(proj, character) {
    try {
      proj.onHitCharacter({
        world,
        projectile: proj,
        character,
        damage: proj.damage,
        spawnParticle: (pt) => world.particles.push(pt),

      applyDamageToPlayer: (amount, sourceProjectile) => applyDamageToCharacter(world.player, amount, sourceProjectile),
      applyDamageToDummy: (amount, sourceProjectile) => {
        const d = world.dummy;
        if (d.isDead) return;
        const prevHp = d.hp;
        d.hp -= amount;
        if (d.hp <= 0 && !d.isDead) {
          d.isDead = true;
          d.hp = 0;
          d.respawnAt = world.time + 1.25;
          if (sourceProjectile && sourceProjectile.onKillDummy) {
            try {
              sourceProjectile.onKillDummy({ world, projectile: sourceProjectile, dummy: d, damage: amount, prevHp, overkill: Math.max(0, -(prevHp - amount)), time: world.time });
            } catch (e) {
              log("onKillDummy ERROR: " + (e?.message || e));
            }
          }
        }
      },
        time: world.time
      });
    } catch (e) {
      log("onHitCharacter ERROR: " + (e?.message || e));
    }
  }

  // ---------- Dummy update (effects) ----------
  function updateDummy(dt) {
    const d = world.dummy;
    const e = d.effects;

    // physics integration
    e.phys.vy += 220 * dt; // mild gravity-ish for "weight"
    d.x += e.phys.vx * dt;
    d.y += e.phys.vy * dt;

    // damping
    e.phys.vx *= Math.pow(0.12, dt);
    e.phys.vy *= Math.pow(0.20, dt);
    e.phys.spin *= Math.pow(0.10, dt);
    e.phys.shake *= Math.pow(0.06, dt);

    // keep dummy on right half
    const W = world.w(), H = world.h();
    d.x = clamp(d.x, W * 0.5 + 30, W - 30 - d.w);
    d.y = clamp(d.y, 30, H - 30 - d.h);

    // decay channels
    e.deform.squash *= Math.pow(0.03, dt);
    e.deform.stretch *= Math.pow(0.03, dt);
    e.deform.shearX *= Math.pow(0.03, dt);
    e.deform.wave *= Math.pow(0.05, dt);

    e.surface.heat *= Math.pow(0.10, dt);
    e.surface.frost *= Math.pow(0.10, dt);
    e.surface.corrosion *= Math.pow(0.10, dt);
    e.surface.wet *= Math.pow(0.10, dt);
    e.surface.tint *= Math.pow(0.10, dt);

    e.aura.intensity *= Math.pow(0.12, dt);
    e.aura.radius *= Math.pow(0.12, dt);

    e.fracture.amount *= Math.pow(0.06, dt);

    e.disintegrate.amount *= Math.pow(0.02, dt);
    e.status.poisoned *= Math.pow(0.06, dt);
    e.status.bleeding *= Math.pow(0.12, dt);

    // disintegration shedding
    if (e.disintegrate.amount > 0.01) {
      const shed = Math.floor(e.disintegrate.shedRate * e.disintegrate.amount * dt);
      for (let i = 0; i < shed; i++) {
        const ax = d.x + Math.random() * d.w;
        const ay = d.y + Math.random() * d.h;
        world.particles.push({
          x: ax, y: ay,
          vx: (Math.random() * 2 - 1) * 80,
          vy: -40 - Math.random() * 120,
          life: 0.55 + Math.random() * 0.55,
          age: 0,
          draw(g, pt) {
            const a = 1 - pt.age / pt.life;
            g.globalAlpha = Math.max(0, a) * 0.35;
            g.fillStyle = "rgba(220,220,220,0.22)";
            g.fillRect(pt.x - 1, pt.y - 1, 2, 2);
            g.globalAlpha = 1;
          }
        });
      }
      e.disintegrate.eraseTo = Math.max(e.disintegrate.eraseTo, 0.25 + 0.6 * e.disintegrate.amount);
    } else {
      e.disintegrate.eraseTo *= Math.pow(0.15, dt);
    }

    // slice parts physics
    if (e.slice.active) {
      for (let i = e.slice.parts.length - 1; i >= 0; i--) {
        const p = e.slice.parts[i];
        p.age += dt;
        p.vy += 420 * dt;
        p.x += p.vx * dt;
        p.y += p.vy * dt;
        p.vx *= Math.pow(0.20, dt);
        p.vy *= Math.pow(0.30, dt);
        p.alpha = Math.max(0, 1 - p.age / p.life);
        if (p.age >= p.life) e.slice.parts.splice(i, 1);
      }
      if (e.slice.parts.length === 0) e.slice.active = false;
    }

    // bleeding / poison emitters (examples)
    if (e.status.bleeding > 0.01 && Math.random() < 0.30 * e.status.bleeding) {
      const ax = d.x + Math.random() * d.w;
      const ay = d.y + Math.random() * d.h;
      world.particles.push({
        x: ax, y: ay,
        vx: (Math.random() * 2 - 1) * 50,
        vy: 40 + Math.random() * 140,
        life: 0.6 + Math.random() * 0.6,
        age: 0,
        draw(g, pt) {
          const a = 1 - pt.age / pt.life;
          g.globalAlpha = Math.max(0, a) * 0.65;
          g.fillStyle = "rgba(160,20,30,0.35)";
          g.fillRect(pt.x - 1, pt.y - 1, 2, 2);
          g.globalAlpha = 1;
        }
      });
    }

    if (e.status.poisoned > 0.01 && Math.random() < 0.22 * e.status.poisoned) {
      const ax = d.x + Math.random() * d.w;
      const ay = d.y + Math.random() * d.h;
      world.particles.push({
        x: ax, y: ay,
        vx: (Math.random() * 2 - 1) * 30,
        vy: -20 - Math.random() * 60,
        life: 0.7 + Math.random() * 0.7,
        age: 0,
        draw(g, pt) {
          const a = 1 - pt.age / pt.life;
          g.globalAlpha = Math.max(0, a) * 0.45;
          g.fillStyle = "rgba(80,220,120,0.22)";
          g.beginPath();
          g.arc(pt.x, pt.y, 2 + a * 3, 0, Math.PI * 2);
          g.fill();
          g.globalAlpha = 1;
        }
      });
    }
  }

  
  function updateRespawns() {
    const W = world.w(), H = world.h();

    // dummy respawn
    if (world.dummy.isDead && world.time >= world.dummy.respawnAt) {
      // reset dummy body + effects
      world.dummy.isDead = false;
      world.dummy.hp = world.dummy.maxHp;
      world.dummy.x = W - 180;
      world.dummy.y = H * 0.5 - world.dummy.h * 0.5;
      world.dummy.deathFx.length = 0;
      // clear effects (keep helper reset logic minimal)
      const e = world.dummy.effects;
      e.phys = { vx: 0, vy: 0, spin: 0, shake: 0 };
      e.deform = { squash: 0, stretch: 0, shearX: 0, wave: 0 };
      e.surface = { heat: 0, frost: 0, corrosion: 0, wet: 0, tint: 0 };
      e.fracture = { amount: 0, seed: 12345, lines: [] };
      e.aura = { intensity: 0, radius: 0, flicker: 0, hue: 190 };
      e.disintegrate = { amount: 0, shedRate: 0, eraseTo: 0 };
      e.slice = { active: false, parts: [] };
      e.status = { poisoned: 0, bleeding: 0 };
    }

    // player respawn
    if (world.player.isDead && world.time >= world.player.respawnAt) {
      world.player.isDead = false;
      world.player.hp = world.player.maxHp;
      world.player.x = 140;
      world.player.y = H * 0.5;
      world.player.deathFx.length = 0;
      world.player.hitFx.length = 0;
    }
  }
// ---------- Update loop ----------
  function update() {
    const t = now();
    world.dt = Math.min(0.033, (t - world.last) / 1000);
    world.last = t;
    world.time += world.dt;

    stepMovement(world.dt);

    // Update projectiles
    for (let i = world.projectiles.length - 1; i >= 0; i--) {
      const p = world.projectiles[i];
      p.age += world.dt;
      p.x += p.vx * world.dt;
      p.y += p.vy * world.dt;

      try { p.trail.emit(world, p, world.time); }
      catch (e) { log("trail.emit ERROR: " + (e?.message || e)); }

      // collision with dummy
      const d = world.dummy;
      if (!d.isDead && circleRectCollides(p.x, p.y, p.radius, d.x, d.y, d.w, d.h)) {
        // apply damage
        const prevHp = d.hp;
        d.hp -= p.damage;
        hitDummy(p);

        if (d.hp <= 0 && !d.isDead) {
          d.isDead = true;
          d.hp = 0;
          d.respawnAt = world.time + 1.25;

          // call custom death effect if provided
          if (p.onKillDummy) {
            try {
              p.onKillDummy({
                world,
                projectile: p,
                dummy: d,
                damage: p.damage,
                prevHp,
                overkill: Math.max(0, - (prevHp - p.damage)),
                time: world.time
              });
            } catch (e) {
              log("onKillDummy ERROR: " + (e?.message || e));
            }
          } else {
            // default death effect (subtle) if no custom provided
            const cx = d.x + d.w * 0.5, cy = d.y + d.h * 0.5;
            for (let k = 0; k < 40; k++) {
              const a = (k / 40) * Math.PI * 2;
              const sp = 120 + Math.random() * 220;
              world.particles.push({
                x: cx, y: cy, vx: Math.cos(a) * sp, vy: Math.sin(a) * sp - 60,
                life: 0.75, age: 0,
                draw(g, pt) {
                  const t = 1 - pt.age / pt.life;
                  g.globalAlpha = Math.max(0, t) * 0.35;
                  g.fillStyle = "rgba(255,255,255,0.10)";
                  g.fillRect(pt.x - 1, pt.y - 1, 2, 2);
                  g.globalAlpha = 1;
                }
              });
            }
          }
        }

        world.projectiles.splice(i, 1);
        continue;
      }

      const W = world.w(), H = world.h();
      if (p.age > p.life || p.x < -80 || p.y < -80 || p.x > W + 80 || p.y > H + 80) {
        world.projectiles.splice(i, 1);
        continue;
      }
    }

    // Update particles
    for (let i = world.particles.length - 1; i >= 0; i--) {
      const pt = world.particles[i];
      pt.age = (pt.age ?? 0) + world.dt;
      const life = pt.life ?? 0.6;
      if (pt.age >= life) { world.particles.splice(i, 1); continue; }
      if (pt.vx) pt.x += pt.vx * world.dt;
      if (pt.vy) pt.y += pt.vy * world.dt;
      if (pt.update) pt.update(world, pt, world.dt);
    }

    updateDummy(world.dt);

    updateRespawns();

    render();
    requestAnimationFrame(update);
  }

  // ---------- Render ----------
  function render() {
    const W = world.w(), H = world.h();
    ctx.clearRect(0, 0, W, H);

    // background
    ctx.fillStyle = "#070a0f";
    ctx.fillRect(0, 0, W, H);

    // arena split
    ctx.fillStyle = "#0a0f16";
    ctx.fillRect(0, 0, W * 0.5, H);
    ctx.fillStyle = "#090d13";
    ctx.fillRect(W * 0.5, 0, W * 0.5, H);

    ctx.strokeStyle = "#233245";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(W * 0.5, 0);
    ctx.lineTo(W * 0.5, H);
    ctx.stroke();

    // player
    if (!world.player.isDead) {
      ctx.fillStyle = "#6fb1ff";
      ctx.beginPath();
      ctx.arc(world.player.x, world.player.y, world.player.r, 0, Math.PI * 2);
      ctx.fill();
    } else {
      // respawn marker
      ctx.globalAlpha = 0.35;
      ctx.fillStyle = "#6fb1ff";
      ctx.beginPath();
      ctx.arc(world.player.x, world.player.y, world.player.r, 0, Math.PI * 2);
      ctx.fill();
      ctx.globalAlpha = 1;
    }

    // aim line
    if (!world.player.isDead) {
      ctx.strokeStyle = "#1e3550";
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(world.player.x, world.player.y);
      ctx.lineTo(world.mouse.x, world.mouse.y);
      ctx.stroke();
    }

    // dummy
    drawDummy(ctx, world.dummy);

    // particles
    for (const pt of world.particles) {
      if (pt.draw) pt.draw(ctx, pt, world.time);
      else {
        const a = 1 - (pt.age / (pt.life ?? 0.6));
        ctx.globalAlpha = clamp(a, 0, 1);
        ctx.fillStyle = pt.color ?? "#8bd3ff";
        ctx.fillRect(pt.x - 1, pt.y - 1, 2, 2);
        ctx.globalAlpha = 1;
      }
    }

    // projectiles
    for (const p of world.projectiles) {
      try { p.shape.draw(ctx, p, world.time); } catch {}
    }

    // HUD
    ctx.fillStyle = "#b9c6d6";
    ctx.font = "12px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace";
    ctx.fillText(`Projectiles: ${world.projectiles.length}`, 12, 18);
    ctx.fillText(`Dummy FX: aura=${world.dummy.effects.aura.intensity.toFixed(2)} fracture=${world.dummy.effects.fracture.amount.toFixed(2)} dis=${world.dummy.effects.disintegrate.amount.toFixed(2)}`, 12, 34);

    // UI HP
    if (hpPill) hpPill.textContent = `HP — Player: ${world.player.hp}/${world.player.maxHp} | Dummy: ${world.dummy.hp}/${world.dummy.maxHp}`;
  }

  function drawDummy(ctx, d) {
    if (d.isDead) {
      // simple death placeholder (actual custom death effects should be done via particles or dummy.effects channels)
      const cx = d.x + d.w * 0.5, cy = d.y + d.h * 0.5;
      ctx.save();
      ctx.globalAlpha = 0.35;
      ctx.strokeStyle = "rgba(255,185,105,0.22)";
      ctx.lineWidth = 6;
      ctx.beginPath();
      ctx.arc(cx, cy, 28, 0, Math.PI * 2);
      ctx.stroke();
      ctx.restore();
      return;
    }

    const e = d.effects;
    const { cx, cy } = dummyCenter(d);

    const erase = clamp(e.disintegrate.eraseTo, 0, 0.95);
    const baseAlpha = 1 - erase;

    ctx.save();

    // Aura behind
    if (e.aura.intensity > 0.01) {
      const flick = 0.75 + 0.25 * Math.sin(world.time * (6 + e.aura.flicker * 8));
      const rad = Math.max(24, e.aura.radius) * (0.85 + 0.15 * flick);
      ctx.globalAlpha = e.aura.intensity * 0.35 * flick;
      ctx.strokeStyle = "rgba(180,240,255,0.22)";
      ctx.lineWidth = 10;
      ctx.beginPath();
      ctx.arc(cx, cy, rad, 0, Math.PI * 2);
      ctx.stroke();
      ctx.globalAlpha = 1;
    }

    // sliced chunks
    if (e.slice.active && e.slice.parts.length) {
      for (const p of e.slice.parts) {
        ctx.save();
        ctx.globalAlpha = p.alpha * 0.9;
        ctx.fillStyle = "rgba(255,185,105,0.85)";
        ctx.fillRect(p.x, p.y, p.w, p.h);

        if (e.fracture.amount > 0.02) {
          ctx.globalAlpha = p.alpha * e.fracture.amount * 0.6;
          ctx.strokeStyle = "rgba(30,25,20,0.55)";
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.moveTo(p.x + 2, p.y + 2);
          ctx.lineTo(p.x + p.w - 2, p.y + p.h - 2);
          ctx.stroke();
        }
        ctx.restore();
      }
      ctx.restore();
      return;
    }

    // deform transform
    const shake = e.phys.shake;
    const shx = (Math.random() * 2 - 1) * 3 * shake;
    const shy = (Math.random() * 2 - 1) * 3 * shake;

    const squash = e.deform.squash;
    const stretch = e.deform.stretch;
    const shearX = e.deform.shearX;
    const wave = e.deform.wave;

    ctx.translate(cx + shx, cy + shy);
    ctx.rotate(e.phys.spin * 0.02);
    ctx.transform(1, 0, shearX * 0.25, 1, 0, 0);
    const sx = 1 + stretch * 0.18 - squash * 0.14;
    const sy = 1 + squash * 0.22 - stretch * 0.10;
    ctx.scale(sx, sy);
    ctx.translate(-cx, -cy);

    // base body
    ctx.globalAlpha = baseAlpha;
    ctx.fillStyle = "rgba(255,185,105,0.95)";
    ctx.fillRect(d.x, d.y, d.w, d.h);

    // face marks
    ctx.fillStyle = "rgba(58,42,26,0.85)";
    ctx.fillRect(d.x + 10, d.y + 16, 8, 8);
    ctx.fillRect(d.x + d.w - 18, d.y + 16, 8, 8);

    // surface overlays
    const surf = e.surface;

    if (surf.heat > 0.01) {
      ctx.globalAlpha = baseAlpha * surf.heat * 0.45;
      ctx.fillStyle = "rgba(255,120,60,0.25)";
      ctx.fillRect(d.x, d.y, d.w, d.h);
    }
    if (surf.frost > 0.01) {
      ctx.globalAlpha = baseAlpha * surf.frost * 0.45;
      ctx.fillStyle = "rgba(170,230,255,0.20)";
      ctx.fillRect(d.x, d.y, d.w, d.h);
    }
    if (surf.corrosion > 0.01) {
      ctx.globalAlpha = baseAlpha * surf.corrosion * 0.45;
      ctx.fillStyle = "rgba(80,220,120,0.16)";
      ctx.fillRect(d.x, d.y, d.w, d.h);
    }
    if (surf.wet > 0.01) {
      ctx.globalAlpha = baseAlpha * surf.wet * 0.35;
      ctx.strokeStyle = "rgba(210,245,255,0.18)";
      ctx.lineWidth = 2;
      ctx.strokeRect(d.x + 1, d.y + 1, d.w - 2, d.h - 2);
    }
    if (surf.tint > 0.01) {
      ctx.globalAlpha = baseAlpha * surf.tint * 0.35;
      ctx.fillStyle = "rgba(200,245,255,0.12)";
      ctx.fillRect(d.x, d.y, d.w, d.h);
    }

    // fracture cracks
    if (e.fracture.amount > 0.01 && e.fracture.lines.length) {
      ctx.globalAlpha = baseAlpha * e.fracture.amount * 0.85;
      ctx.strokeStyle = "rgba(30,25,20,0.55)";
      ctx.lineWidth = 1.2;
      for (const line of e.fracture.lines) {
        ctx.beginPath();
        for (let i = 0; i < line.length; i++) {
          const p = line[i];
          if (i === 0) ctx.moveTo(p.x, p.y);
          else ctx.lineTo(p.x, p.y);
        }
        ctx.stroke();
      }
      ctx.globalAlpha = 1;
    }

    // wave lines
    if (wave > 0.01) {
      ctx.globalAlpha = baseAlpha * wave * 0.35;
      ctx.strokeStyle = "rgba(255,255,255,0.10)";
      ctx.lineWidth = 2;
      for (let i = 0; i < 6; i++) {
        const yy = d.y + (i + 1) * (d.h / 7);
        const wig = Math.sin(world.time * 9 + i * 1.3) * (10 * wave);
        ctx.beginPath();
        ctx.moveTo(d.x - 6, yy);
        ctx.quadraticCurveTo(d.x + d.w * 0.5 + wig, yy - 6, d.x + d.w + 6, yy);
        ctx.stroke();
      }
    }

    ctx.restore();
  }

  // ---------- Paste code loader ----------
  function loadPastedPower(code) {
    clearLog();
    const sandboxGlobals = { registerPower };
    const fn = new Function(...Object.keys(sandboxGlobals), `"use strict";\n${code}\n`);
    fn(...Object.values(sandboxGlobals));
  }

  btnLoadPower.addEventListener("click", () => {
    try {
      const code = powerCodeEl.value.trim();
      if (!code) return log("Nothing to load.");
      loadPastedPower(code);
      world.lastLoadedCode = code;
      if (!world.currentPower) log("Loaded code did not call registerPower(...).");
    } catch (e) {
      log("LOAD ERROR: " + (e?.message || e));
      world.currentPower = null;
      statusPill.textContent = "No power loaded";
    }
  });

  btnLoadExample.addEventListener("click", () => {
    powerCodeEl.value = EXAMPLE_POWER_CODE.trim();
    log("Example pasted. Click 'Load Pasted Power'.");
  });

  btnReset.addEventListener("click", resetArena);
  btnClear.addEventListener("click", () => powerCodeEl.value = "");
  btnCopyLastPower.addEventListener("click", async () => {
    const txt = world.lastLoadedCode || powerCodeEl.value || "";
    if (!txt) return log("No code to copy.");
    await navigator.clipboard.writeText(txt);
    log("Copied last power code to clipboard.");
  });

  // ---------- Copy instructions ----------
  const INSTRUCTIONS_TEXT = `
You are generating a SINGLE JavaScript power module for a projectile/blast sandbox.
The output MUST be ONLY code. No markdown. No explanation.

HARD REQUIREMENTS (minimum valid power):
- This sandbox has HP + death. Player max HP = 100. Dummy max HP = 300.
- Damage can exceed 100 (overkill allowed). If HP <= 0, death triggers.
- OPTIONAL: Provide custom death effects via onKillDummy/onKillCharacter.

- The power is a projectile/blast.
- Projectile MUST have a custom shape made from scratch (unique geometry/visual form).
- Projectile MUST have a custom trail (not a standard line; it must have unique behavior).
- Custom travel speed (explicit numeric speed + any motion behavior if desired).
- Custom damage (explicit numeric).
- Custom on-hit effect for characters: entirely customized and specific.
- Custom dummy effect: entirely customized and specific (e.g., slice, erase, deform, fracture, aura, disintegrate, poison/blood, etc.), not limited to a fixed list.

Your code MUST call:
registerPower({
  meta: { id: "unique_id", name: "Power Name", description: "1-2 lines" },
  createProjectile(ctx) { return projectileSpec; }
});

The createProjectile(ctx) must return:
{
  speed: <number>,         // pixels/sec
  damage: <number>,
  radius: <number>,        // collision radius
  life: <number>,          // seconds (optional)
  state: <object>,         // optional per-projectile state
  shape: { draw(canvasCtx, proj, t) { /* draw custom shape */ } },
  trail: { emit(world, proj, t) { /* push particles into world.particles */ } },
  onHitCharacter({ world, projectile, character, damage, spawnParticle, time }) { /* custom */ },
  onHitDummy({ world, projectile, dummy, damage, spawnParticle, time }) { /* custom dummy effect */ },
  // OPTIONAL death hooks (called only when HP goes to 0 or below)
  onKillDummy({ world, projectile, dummy, damage, prevHp, overkill, time }) { /* custom death effect */ },
  onKillCharacter({ world, projectile, character, damage, prevHp, overkill, time }) { /* custom death effect */ }
}

Extra helpers:
- ctx.applyDamageToPlayer(amount, sourceProjectile)
- ctx.applyDamageToDummy(amount, sourceProjectile)

Dummy effect system (available via ctx.dummyHelpers):
- addKnockback(vx, vy, spin)
- addFracture(amount, seed)
- setAura(intensity, radius, hue, flicker)
- setSurface({heat,frost,corrosion,wet,tint})
- startDisintegration(amount, shedRate, eraseTo)
- setStatus({poisoned, bleeding})
- sliceDummy(partsCount, directionAngle)

You can also directly set dummy.effects.deform.{squash,stretch,shearX,wave} for deformation.

Notes:
- Use only vanilla JS. No external libs. No presets.
- Make the shape and trail feel unique: avoid "simple circle + simple line trail".
Return ONLY the JS code.
`.trim();

  btnCopyInstructions.addEventListener("click", async () => {
    await navigator.clipboard.writeText(INSTRUCTIONS_TEXT);
    log("Copied generation instructions to clipboard.");
  });

  // ---------- Example power (showcases multiple dummy channels) ----------
  const EXAMPLE_POWER_CODE = `
registerPower({
  meta: {
    id: "fx_showcase_01",
    name: "FX Showcase Bolt",
    description: "A debug bolt that triggers different dummy effect channels each hit."
  },

  createProjectile(ctx) {
    const rng = ctx.rng;

    // custom jagged diamond
    const pts = [];
    const n = 9 + Math.floor(rng() * 5);
    for (let i=0;i<n;i++){
      const a = (i/n)*Math.PI*2;
      const r = 6 + rng()*10 + (i%2? rng()*6:0);
      pts.push({x:Math.cos(a)*r, y:Math.sin(a)*r*(0.7+rng()*0.6)});
    }

    return {
      speed: 740,
      damage: 20,
      radius: 12,
      life: 2.2,
      state: { pts, spin: (rng()<0.5?-1:1)*(3+rng()*4) },

      shape: {
        draw(g, proj, t){
          const s=proj.state;
          const ang=Math.atan2(proj.vy, proj.vx);
          g.save();
          g.translate(proj.x, proj.y);
          g.rotate(ang + t*s.spin*0.12);
          g.globalAlpha=0.35;
          g.fillStyle="rgba(200,245,255,0.18)";
          g.beginPath();
          for(let i=0;i<s.pts.length;i++){ const p=s.pts[i]; if(i===0)g.moveTo(p.x*1.3,p.y*1.3); else g.lineTo(p.x*1.3,p.y*1.3); }
          g.closePath(); g.fill();
          g.globalAlpha=1;
          g.fillStyle="rgba(140,220,255,0.55)";
          g.beginPath();
          for(let i=0;i<s.pts.length;i++){ const p=s.pts[i]; if(i===0)g.moveTo(p.x,p.y); else g.lineTo(p.x,p.y); }
          g.closePath(); g.fill();
          g.strokeStyle="rgba(255,255,255,0.75)"; g.lineWidth=2; g.stroke();
          g.restore();
          g.globalAlpha=1;
        }
      },

      trail: {
        emit(world, proj, t){
          // ribbon trail
          const vlen=Math.max(1e-6, Math.hypot(proj.vx, proj.vy));
          const bx=-proj.vx/vlen, by=-proj.vy/vlen;
          const px=-by, py=bx;
          for(let i=0;i<2;i++){
            const off=(Math.random()*2-1)*10;
            world.particles.push({
              x: proj.x + px*off,
              y: proj.y + py*off,
              vx: bx*(60+Math.random()*90) + px*(Math.random()*50-25),
              vy: by*(60+Math.random()*90) + py*(Math.random()*50-25),
              life: 0.45+Math.random()*0.25,
              age: 0,
              draw(g, pt){
                const a=1-pt.age/pt.life;
                g.globalAlpha=Math.max(0,a);
                g.fillStyle=a>0.5?"rgba(180,240,255,0.20)":"rgba(255,255,255,0.10)";
                g.fillRect(pt.x-6, pt.y-2, 12, 4);
                g.globalAlpha=1;
              }
            });
          }
        }
      },

      onHitCharacter(){},

      onHitDummy({ dummy, projectile, time, world }){
        // cycle effects
        dummy._fxMode = (dummy._fxMode || 0) + 1;
        const m = dummy._fxMode % 6;
        const H = ctx.dummyHelpers;

        if(m===0){
          H.addKnockback(260, -180, 18);
          dummy.effects.deform.squash = 1;
          dummy.effects.deform.wave = 0.7;
        } else if(m===1){
          H.setAura(1, 90, 180, 1.0);
          H.addFracture(0.8);
        } else if(m===2){
          H.setSurface({ heat: 1 });
          H.setStatus({ bleeding: 1 });
        } else if(m===3){
          H.setSurface({ corrosion: 1 });
          H.setStatus({ poisoned: 1 });
        } else if(m===4){
          H.startDisintegration(1, 130, 0.9);
          H.setAura(0.6, 120, 140, 0.8);
        } else {
          const ang=Math.atan2(projectile.vy, projectile.vx);
          H.sliceDummy(8, ang);
          H.addFracture(0.4);
        }

        // impact burst
        const cx=dummy.x+dummy.w*0.5, cy=dummy.y+dummy.h*0.5;
        for(let i=0;i<22;i++){
          const a=(i/22)*Math.PI*2;
          const sp=120+Math.random()*220;
          world.particles.push({
            x:cx,y:cy,vx:Math.cos(a)*sp,vy:Math.sin(a)*sp,
            life:0.55,age:0,
            draw(g,pt){
              const k=1-pt.age/pt.life;
              g.globalAlpha=Math.max(0,k)*0.5;
              g.fillStyle="rgba(220,250,255,0.18)";
              g.fillRect(pt.x-1,pt.y-1,2,2);
              g.globalAlpha=1;
            }
          });
        }
      }
    };
  }
});
`.trim();

  // ---------- Start loop ----------
  requestAnimationFrame(update);

})();
</script>
</body>
</html>
